#### Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ"
```shell
  1 #!/bin/bash
  2
  3 read -p "What is your naem: " name
  4 echo "Hello, ${name}"
```

#### Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.

```shell
  1 #!/bin/bash
  2
  3 read -p "Username: " username
  4 echo "Active sessions: " $(who | grep "^${username}" | wc -l)
```

#### Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния изход подходящо съобщение за броя на всички файлове и всички директории в нея.

```shell
  1 #!/bin/bash
  2
  3 read -p "Enter directory: " dirname
  4 if [ ! -d $dirname ]
  5 then
  6     echo " $dirname is not a dir"
  7     exit
  8 fi
  9
 10 num_dirs=$(find $dirname -mindepth 1 2>/dev/null -type d | wc -l)
 11 num_files=$(find $dirname -type f | wc -l)
 12 echo "Num of files: ${num_files}"
 13 echo "Num of dirs: ${num_dirs}"

```

#### Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.
```shell
  1 #!/bin/bash
  2
  3 read -p "Enter 3 file names: " f1 f2 f3
  4 paste -d'\n' $f1 $f2 | sort -d -i >> $f3
```

#### Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа. NB! Символният низ може да съдържа интервал (' ') в себе си.
```shell
  1 #!/bin/bash
  2
  3 read -p "Enter file name and string: " fname str
  4 cat $fname | grep -q $str
  5 echo $?
```
#### Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане).
Примерен .c файл:
#include <stdio.h>

int main(int argc, char *argv[]) {

  if (argc == 1) {
		printf("There is only 1 argument");
	} else {
		printf("There are more than 1 arguments");
	}

	return 0;
}
Тук влагането е 2, понеже имаме main блок, а вътре в него if блок.

#### Примерно извикване на скрипта: ./count_nesting sum_c_code.c

#### Изход: The deepest nesting is 2 levels

```shell
 1 #!/bin/bash
  2
  3 grep -o '[{}]' "${1}" | uniq -c | awk 'BEGIN{max=0; curr=0} $2=="{" {curr = curr+$1} $2=="}" {curr = curr-$1} curr>max {max=curr} END{print max}'
```

#### Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи: име на файла указател, пълно име на човека (това, което очакваме да е в /etc/passwd) и избран за него nickname.
Файлът указател нека да е във формат:
<nickname, който лесно да запомните> <username в os-server>
// може да сложите и друг delimiter вместо интервал

Примерно извикване:
./pupulate_address_book myAddressBook "Ben Dover" uncleBen

#### Добавя към myAddressBook entry-то:
uncleBen <username на Ben Dover в os-server>

```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и опционално експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.

```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение. NB! Можете да тествате по същият начин като в 05-b-4300.txt
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал. Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала. Скриптът да връща exit status:
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

#### Примери:
`$ ./validint.sh -42 0 102; echo $?`
1

```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```


#### Да се напише shell скрипт, който форматира големи числа, за да са по-лесни за четене. Като пръв аргумент на скрипта се подава цяло число. Като втори незадължителен аргумент се подава разделител. По подразбиране цифрите се разделят с празен интервал.

#### Примери:
$ ./nicenumber.sh 1889734853
1 889 734 853

$ ./nicenumber.sh 7632223 ,
7,632,223

```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```
#### Да се напише shell скрипт, който приема файл и директория. Скриптът проверява в подадената директория и нейните под-директории дали съществува копие на подадения файл и отпечатва имената на намерените копия, ако съществуват такива. NB! Под 'копие' разбираме файл със същото съдържание.
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell script, който генерира HTML таблица съдържаща описание на потребителите във виртуалката ви. Таблицата трябва да има:
- заглавен ред с имената нa колоните
- колони за username, group, login shell, GECOS field (https://en.wikipedia.org/wiki/Gecos_field)

#### Пример:
$ ./passwd-to-html.sh > table.html
$ cat table.html
<table>
  <tr>
    <th>Username</th>
    <th>group</th>
    <th>login shell</th>
    <th>GECOS</th>
  </tr>
  <tr>
    <td>root</td>
    <td>root</td>
    <td>/bin/bash</td>
    <td>GECOS here</td>
  </tr>
  <tr>
    <td>ubuntu</td>
    <td>ubuntu</td>
    <td>/bin/dash</td>
    <td>GECOS 2</td>
  </tr>
</table>
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение. NB! Можете да тествате по същият начин като в 05-b-4300.txt
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение. NB! Можете да тествате по същият начин като в 05-b-4300.txt
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```

#### Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение. NB! Можете да тествате по същият начин като в 05-b-4300.txt
```shell
  1 #!/bin/bash
  2
  3 if echo "${1}" | grep -Eq '^[a-z0-9]*$'; then
  4     echo "true"
  5 else
  6     echo "false"
  7 fi
```
